import { serverInit } from '../../../../server'

import { knex, prepareDbForTests, sqlClose, sqlInit } from '../../../../databases/sql'

describe('UnHappy Path get action statuses endpoint test with DB connection', () => {
  const actionTableName = 'action'

  const testUrl = '/api/actions/getactionstatuses'
  const testMethod = 'POST'

  let server

  beforeAll(async () => {
    await sqlInit()
    server = await serverInit()
    await prepareDbForTests()
  })

  afterAll(async () => {
    await knex(actionTableName).truncate()
    await server.stop()
    await sqlClose()
  })

  describe('Against the business logic tests', () => {
    test('should return 403 end error details when the request"s account id doesn"t belong to the child)', async () => {
      const injectOptions = {
        method: testMethod,
        url: testUrl,
        payload: { accountId: 1, childId: 2 },
      }

      //The timeStamps are generated by the date.now so the test doesn't check the exact value
      const expectedResponse = {
        code: 403,
        isValid: false,
        errorMessage: 'Access Denied!',
        hashValue: null,
        error: null,
        isAdmin: false,
      }

      const res = await server.inject(injectOptions)

      const responseBody = JSON.parse(res.payload)

      expect(res.statusCode).toEqual(403)
      expect(responseBody.errorMessage).toEqual(expectedResponse.errorMessage)
    })
  })

  describe('Joi validation error tests', () => {
    test('should return 400 end error detailsthe accountId is missing from the request body)', async () => {
      const injectOptions = {
        method: testMethod,
        url: testUrl,
        payload: { childId: 2 },
      }

      //The timeStamps are generated by the date.now so the test doesn't check the exact value
      const expectedResponse = {
        code: 400,
        isValid: false,
        errorMessage: 'RequestBody Validation Failed',
        hashValue: null,
        error: [
          {
            message: '"accountId" is required',
            path: ['accountId'],
            type: 'any.required',
            context: { label: 'accountId', key: 'accountId' },
          },
        ],
        isAdmin: false,
      }

      const res = await server.inject(injectOptions)

      const responseBody = JSON.parse(res.payload)

      expect(res.statusCode).toEqual(400)
      expect(responseBody.errorMessage).toEqual(expectedResponse.errorMessage)
      expect(responseBody.error).toEqual(expectedResponse.error)
    })

    test('should return 400 end error details when the childId is missing from the request body)', async () => {
      const injectOptions = {
        method: testMethod,
        url: testUrl,
        payload: { accountId: 1 },
      }

      //The timeStamps are generated by the date.now so the test doesn't check the exact value
      const expectedResponse = {
        code: 400,
        isValid: false,
        errorMessage: 'RequestBody Validation Failed',
        hashValue: null,
        error: [
          {
            message: '"childId" is required',
            path: ['childId'],
            type: 'any.required',
            context: { label: 'childId', key: 'childId' },
          },
        ],
        isAdmin: false,
      }

      const res = await server.inject(injectOptions)

      const responseBody = JSON.parse(res.payload)

      expect(res.statusCode).toEqual(400)
      expect(responseBody.errorMessage).toEqual(expectedResponse.errorMessage)
      expect(responseBody.error).toEqual(expectedResponse.error)
    })

    test('should return 400 end error details when the childId"s type is not a number)', async () => {
      const injectOptions = {
        method: testMethod,
        url: testUrl,
        payload: { accountId: 1, childId: 'iamastring' },
      }

      //The timeStamps are generated by the date.now so the test doesn't check the exact value
      const expectedResponse = {
        code: 400,
        isValid: false,
        errorMessage: 'RequestBody Validation Failed',
        hashValue: null,
        error: [
          {
            message: '"childId" must be a number',
            path: ['childId'],
            type: 'number.base',
            context: { label: 'childId', value: 'iamastring', key: 'childId' },
          },
        ],
        isAdmin: false,
      }

      const res = await server.inject(injectOptions)

      const responseBody = JSON.parse(res.payload)

      expect(res.statusCode).toEqual(400)
      expect(responseBody.errorMessage).toEqual(expectedResponse.errorMessage)
      expect(responseBody.error).toEqual(expectedResponse.error)
    })

    test('should return 400 end error details when the accountID"s type is not a number)', async () => {
      const injectOptions = {
        method: testMethod,
        url: testUrl,
        payload: { accountId: 'iamastring', childId: 1 },
      }

      //The timeStamps are generated by the date.now so the test doesn't check the exact value
      const expectedResponse = {
        code: 400,
        isValid: false,
        errorMessage: 'RequestBody Validation Failed',
        hashValue: null,
        error: [
          {
            message: '"accountId" must be a number',
            path: ['accountId'],
            type: 'number.base',
            context: { label: 'accountId', value: 'iamastring', key: 'accountId' },
          },
        ],
        isAdmin: false,
      }

      const res = await server.inject(injectOptions)

      const responseBody = JSON.parse(res.payload)

      expect(res.statusCode).toEqual(400)
      expect(responseBody.errorMessage).toEqual(expectedResponse.errorMessage)
      expect(responseBody.error).toEqual(expectedResponse.error)
    })
  })
})
